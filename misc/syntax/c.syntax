# Syntax rules for the C and the C++ programming languages

context default
    keyword whole asm			storage.type.c
    keyword whole auto			storage.type.c
    keyword whole bool			storage.type.c
    keyword whole char			storage.type.c
    keyword whole double		storage.type.c
    keyword whole enum			storage.type.c
    keyword whole float			storage.type.c
    keyword whole int			storage.type.c
    keyword whole long			storage.type.c
    keyword whole short			storage.type.c
    keyword whole signed		storage.type.c
    keyword whole struct		storage.type.c
    keyword whole typedef		storage.type.c
    keyword whole union			storage.type.c
    keyword whole unsigned		storage.type.c
    keyword whole void			storage.type.c

    keyword whole const			storage.modifier.c
    keyword whole extern		storage.modifier.c
    keyword whole inline		storage.modifier.c
    keyword whole register		storage.modifier.c
    keyword whole restrict		storage.modifier.c
    keyword whole static		storage.modifier.c
    keyword whole volatile		storage.modifier.c

    keyword whole break			keyword.control.c
    keyword whole case			keyword.control.c
    keyword whole continue		keyword.control.c
    keyword whole do			keyword.control.c
    keyword whole else			keyword.control.c
    keyword whole for			keyword.control.c
    keyword whole goto			keyword.control.c
    keyword whole if			keyword.control.c
    keyword whole return		keyword.control.c
    keyword whole switch		keyword.control.c
    keyword whole while			keyword.control.c

    keyword whole linestart \{\s\t\}\[\s\t\]#*\n meta.preprocessor.c

    keyword whole linestart \[\s\t\]\{ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\}\[0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\]: constant.other.reference.label.c

    keyword /\*	comment.block.c
    keyword \*/	comment.block.c
    keyword //	comment.line.double-slash.c++

    keyword '\\\{"abtnvfr\}'	constant.character.escape.c
    keyword '\\\{0123\}\{01234567\}\{01234567\}' constant.character.escape.c
    keyword '\\''		constant.character.escape.c
    keyword '\\\\'		constant.character.escape.c
    keyword '\\0'		constant.character.escape.c

    keyword FALSE		constant.language.false.c
    keyword false		constant.language.false.c
    keyword NULL		constant.language.null.c
    keyword TRUE		constant.language.true.c
    keyword true		constant.language.true.c

    keyword '\{\s!"#$%&()\*\+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\}' string.quoted.single.c

# punctuation characters, sorted by ASCII code
    keyword whole sizeof keyword.operator.sizeof.c
    keyword ,	keyword.operator.other.c
    keyword ?	keyword.operator.other.ternary.c
    keyword :	keyword.operator.other.ternary.c

    keyword (	punctuation.other.open-paren.c
    keyword )	punctuation.other.close-paren.c
    keyword ;	punctuation.other.semi-colon.c
    keyword [	punctuation.array.open-bracket.c
    keyword ]	punctuation.array.close-bracket.c
    keyword {	punctuation.scope.open-paren.c
    keyword }	punctuation.scope.close-paren.c

    keyword \[%&\*\+-/^~\]= keyword.operator.assignment.augmented.c
    keyword &&=	keyword.operator.assignment.augmented.c
    keyword ||=	keyword.operator.assignment.augmented.c
    keyword >>=	keyword.operator.assignment.augmented.c
    keyword <<=	keyword.operator.assignment.augmented.c

    keyword \+\+ keyword.operator.assignment.c
    keyword --	keyword.operator.assignment..c

    keyword ==	keyword.operator.comparison.c
    keyword !=	keyword.operator.comparison.c
    keyword <=	keyword.operator.comparison.c
    keyword >=	keyword.operator.comparison.c

    keyword !	keyword.operator.logical.c
    keyword &&	keyword.operator.logical.c
    keyword ||	keyword.operator.logical.c

    keyword &	keyword.operator.bitwise.c
    keyword |	keyword.operator.bitwise.c
    keyword ^	keyword.operator.bitwise.c
    keyword ~	keyword.operator.bitwise.c
    keyword <<	keyword.operator.bitwise.c
    keyword >>	keyword.operator.bitwise.c

    keyword <	keyword.operator.logical.c
    keyword >	keyword.operator.logical.c

    keyword %	keyword.operator.arithmetic.c
    keyword \*	keyword.operator.arithmetic.c
    keyword \+	keyword.operator.arithmetic.c
    keyword -	keyword.operator.arithmetic.c
    keyword /	keyword.operator.arithmetic.c
    keyword =	keyword.operator.assignment.c

context exclusive /\* \*/ comment.block.c
    spellcheck

context exclusive // \n comment.line.double-slash.c++
    spellcheck

context linestart # \n meta.preprocessor.c
    keyword \\\n meta.preprocessor.escape.newline.c
    keyword /\**\*/ comment.block.c
    keyword //*\n comment.line.double-slash.c++
    keyword whole include meta.preprocessor.include.c
    keyword "+" string.quoted.double.include.c
    keyword <+> string.quoted.other.lt-gt.include.c

context " " string.quoted.double.c
    spellcheck
    keyword \\"									constant.character.escape.c
    keyword %%									constant.character.escape.c
    keyword %\[#0\s-\+,\]\[0123456789\*\]\[.\]\[0123456789\*\]\[L\]\{eEfgGoxX\}	constant.other.placeholder.c
    keyword %\[0\s-\+,\]\[0123456789\*\]\[.\]\[0123456789\*\]\[hl\]\{diuxX\}	constant.other.placeholder.c
    keyword %\[hl\]n								constant.other.placeholder.c
    keyword %\[-\]\[0123456789\*\]\[.\]\[0123456789\*\]s			constant.other.placeholder.c
    keyword %c									constant.other.placeholder.c
    keyword %p									constant.other.placeholder.c
    keyword %[*]								invalid.illegal.placeholder.c
    keyword \\\{0123\}\{01234567\}\{01234567\}					constant.character.escape.c
    keyword \\\\								constant.character.escape.c
    keyword \\\{abtnvfr\}							constant.character.escape.c
